<template>
  <div>
    <h1>构造函数</h1>
<h2>基本使用</h2>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mindMapContainer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">import</span> MindMap <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;simple-mind-map&quot;</span>;

<span class="hljs-keyword">const</span> mindMap = <span class="hljs-keyword">new</span> MindMap({
  <span class="hljs-attr">el</span>: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;mindMapContainer&#x27;</span>),
  <span class="hljs-attr">data</span>: {
    <span class="hljs-string">&quot;data&quot;</span>: {
        <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;根节点&quot;</span>
    },
    <span class="hljs-string">&quot;children&quot;</span>: []
  }
});
</code></pre>
<h2>实例化选项</h2>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>el</td>
<td>Element</td>
<td></td>
<td>容器元素，必传，必须为DOM元素</td>
</tr>
<tr>
<td>data</td>
<td>Object</td>
<td>{}</td>
<td>思维导图数据，可参考下方【数据结构】介绍</td>
</tr>
<tr>
<td>layout</td>
<td>String</td>
<td>logicalStructure</td>
<td>布局类型，可选列表：logicalStructure（逻辑结构图）、mindMap（思维导图）、catalogOrganization（目录组织图）、organizationStructure（组织结构图）、timeline（v0.5.4+，时间轴）、timeline2（v0.5.4+，上下交替型时间轴）、fishbone（v0.5.4+，鱼骨图）</td>
</tr>
<tr>
<td>fishboneDeg（v0.5.4+）</td>
<td>Number</td>
<td>45</td>
<td>设置鱼骨结构图的斜线角度</td>
</tr>
<tr>
<td>theme</td>
<td>String</td>
<td>default</td>
<td>主题，可选列表：default（默认）、classic（脑图经典）、minions（小黄人）、pinkGrape（粉红葡萄）、mint（薄荷）、gold（金色vip）、vitalityOrange（活力橙）、greenLeaf（绿叶）、dark2（暗色2）、skyGreen（天清绿）、classic2（脑图经典2）、classic3（脑图经典3）、classic4（脑图经典4，v0.2.0+）、classicGreen（经典绿）、classicBlue（经典蓝）、blueSky（天空蓝）、brainImpairedPink（脑残粉）、dark（暗色）、earthYellow（泥土黄）、freshGreen（清新绿）、freshRed（清新红）、romanticPurple（浪漫紫）、simpleBlack（v0.5.4+简约黑）、courseGreen（v0.5.4+课程绿）、coffee（v0.5.4+咖啡）、redSpirit（v0.5.4+红色精神）、blackHumour（v0.5.4+黑色幽默）、lateNightOffice（v0.5.4+深夜办公室）、blackGold（v0.5.4+黑金）、avocado（v.5.10-fix.2+牛油果）、autumn（v.5.10-fix.2+秋天）、orangeJuice（v.5.10-fix.2+橙汁）</td>
</tr>
<tr>
<td>themeConfig</td>
<td>Object</td>
<td>{}</td>
<td>主题配置，会和所选择的主题进行合并，可用字段可参考：<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/src/themes/default.js">default.js</a></td>
</tr>
<tr>
<td>scaleRatio</td>
<td>Number</td>
<td>0.1</td>
<td>放大缩小的增量比例</td>
</tr>
<tr>
<td>maxTag</td>
<td>Number</td>
<td>5</td>
<td>节点里最多显示的标签数量，多余的会被丢弃</td>
</tr>
<tr>
<td>exportPadding</td>
<td>Number</td>
<td>20</td>
<td>导出图片时的内边距</td>
</tr>
<tr>
<td>imgTextMargin</td>
<td>Number</td>
<td>5</td>
<td>节点里图片和文字的间距</td>
</tr>
<tr>
<td>textContentMargin</td>
<td>Number</td>
<td>2</td>
<td>节点里各种文字信息的间距，如图标和文字的间距</td>
</tr>
<tr>
<td>selectTranslateStep</td>
<td>Number</td>
<td>3</td>
<td>多选节点时鼠标移动到边缘时的画布移动偏移量</td>
</tr>
<tr>
<td>selectTranslateLimit</td>
<td>Number</td>
<td>20</td>
<td>多选节点时鼠标移动距边缘多少距离时开始偏移</td>
</tr>
<tr>
<td>customNoteContentShow（v0.1.6+）</td>
<td>Object</td>
<td>null</td>
<td>自定义节点备注内容显示，Object类型，结构为：{show: (noteContent, left, top, node) =&gt; {// 你的显示节点备注逻辑。node为v0.8.1+版本新增的回参，代表节点实例 }, hide: () =&gt; {// 你的隐藏节点备注逻辑 }}</td>
</tr>
<tr>
<td>readonly（v0.1.7+）</td>
<td>Boolean</td>
<td>false</td>
<td>是否是只读模式</td>
</tr>
<tr>
<td>enableFreeDrag（v0.2.4+）</td>
<td>Boolean</td>
<td>false</td>
<td>是否开启节点自由拖拽（自由拖拽即可以把节点拖拽到画布的任意位置，注意不是拖拽节点成为其他节点的子节点兄弟节点的功能，自由拖拽的连线会存在一定问题，所以该特性最好不要使用）</td>
</tr>
<tr>
<td>watermarkConfig（v0.2.4+）</td>
<td>Object</td>
<td></td>
<td>水印配置，详细配置请参考下方表格【水印配置】</td>
</tr>
<tr>
<td>textAutoWrapWidth（v0.3.4+）</td>
<td>Number</td>
<td>500</td>
<td>节点内每行文本达到该宽度后自动换行</td>
</tr>
<tr>
<td>customHandleMousewheel（v0.4.3+）</td>
<td>Function</td>
<td>null</td>
<td>自定义鼠标滚轮事件处理，可以传一个函数，回调参数为事件对象</td>
</tr>
<tr>
<td>mousewheelAction（v0.4.3+）</td>
<td>String</td>
<td>zoom（v0.9.1+默认改为move）</td>
<td>鼠标滚轮的行为，<code>zoom</code>（放大缩小）、<code>move</code>（上下移动）。如果<code>customHandleMousewheel</code>传了自定义函数，这个属性不生效</td>
</tr>
<tr>
<td>mousewheelMoveStep（v0.4.3+）</td>
<td>Number</td>
<td>100</td>
<td>当<code>mousewheelAction</code>设为<code>move</code>时，可以通过该属性控制鼠标滚动一下视图移动的步长，单位<code>px</code></td>
</tr>
<tr>
<td>mousewheelZoomActionReverse（v0.6.5+）</td>
<td>Boolean</td>
<td>false（v0.9.1+默认改为true）</td>
<td>当mousewheelAction设为zoom时，或者按住Ctrl键时，默认向前滚动是缩小，向后滚动是放大，如果该属性设为true，那么会反过来</td>
</tr>
<tr>
<td>defaultInsertSecondLevelNodeText（v0.4.7+）</td>
<td>String</td>
<td>二级节点</td>
<td>默认插入的二级节点的文字</td>
</tr>
<tr>
<td>defaultInsertBelowSecondLevelNodeText（v0.4.7+）</td>
<td>String</td>
<td>分支主题</td>
<td>默认插入的二级以下节点的文字</td>
</tr>
<tr>
<td>expandBtnStyle（v0.5.0+）</td>
<td>Object</td>
<td>{ color: '#808080', fill: '#fff', fontSize: 13, strokeColor: '#333333' }</td>
<td>展开收起按钮的颜色，（fontSize及strokeColor字段为0.7.0+版本新增的，用于设置收起时显示节点数量的文字样式）</td>
</tr>
<tr>
<td>expandBtnIcon（v0.5.0+）</td>
<td>Object</td>
<td>{ open: '', close: '' }</td>
<td>自定义展开收起按钮的图标，可以传图标的svg字符串</td>
</tr>
<tr>
<td>expandBtnNumHandler（v0.7.0+）</td>
<td>Function</td>
<td></td>
<td>用于自定义收起时显示节点数量的内容，接收一个参数，代表收起的节点实例，需要返回一个数字或字符串，代表最终显示的内容，比如你可以当数量大于99时，显示99+</td>
</tr>
<tr>
<td>isShowExpandNum（v0.7.0+）</td>
<td>Boolean</td>
<td>true</td>
<td>节点收起时是否显示收起的数量</td>
</tr>
<tr>
<td>enableShortcutOnlyWhenMouseInSvg（v0.5.1+）</td>
<td>Boolean</td>
<td>true</td>
<td>是否只有当鼠标在画布内才响应快捷键事件</td>
</tr>
<tr>
<td>enableNodeTransitionMove（v0.5.1+）（v0.6.7+已去除该特性）</td>
<td>Boolean</td>
<td>true</td>
<td>是否开启节点动画过渡</td>
</tr>
<tr>
<td>nodeTransitionMoveDuration（v0.5.1+）（v0.6.7+已去除该特性）</td>
<td>Number</td>
<td>300</td>
<td>如果开启节点动画过渡，可以通过该属性设置过渡的时间，单位ms</td>
</tr>
<tr>
<td>initRootNodePosition（v0.5.3+）</td>
<td>Array</td>
<td>null</td>
<td>初始根节点的位置，可传一个数组，默认为<code>['center', 'center']</code>，代表根节点处于画布中心位置，除了<code>center</code>，关键词还可以设置<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>，除了可以传关键词，数组的每项还可以传递一个数字，代表具体的像素，可以传递一个百分比字符串，比如<code>['40%', '60%']</code>，代表水平位置在画布宽度的<code>40%</code>的位置，垂直位置在画布高度的<code>60%</code>的位置</td>
</tr>
<tr>
<td>exportPaddingX（v0.5.5+）</td>
<td>Number</td>
<td>10</td>
<td>导出png、svg、pdf时的图形水平内边距</td>
</tr>
<tr>
<td>exportPaddingY（v0.5.5+）</td>
<td>Number</td>
<td>10</td>
<td>导出png、svg、pdf时的图形垂直内边距</td>
</tr>
<tr>
<td>nodeTextEditZIndex（v0.5.5+）</td>
<td>Number</td>
<td>3000</td>
<td>节点文本编辑框元素的z-index</td>
</tr>
<tr>
<td>nodeNoteTooltipZIndex（v0.5.5+）</td>
<td>Number</td>
<td>3000</td>
<td>节点备注浮层元素的z-index</td>
</tr>
<tr>
<td>isEndNodeTextEditOnClickOuter（v0.5.5+）</td>
<td>Boolean</td>
<td>true</td>
<td>是否在点击了画布外的区域时结束节点文本的编辑状态</td>
</tr>
<tr>
<td>maxHistoryCount（v0.5.6+）</td>
<td>Number</td>
<td>1000</td>
<td>最大历史记录数</td>
</tr>
<tr>
<td>alwaysShowExpandBtn（v0.5.8+）</td>
<td>Boolean</td>
<td>false</td>
<td>是否一直显示节点的展开收起按钮，默认为鼠标移上去和激活时才显示</td>
</tr>
<tr>
<td>iconList（v0.5.8+）</td>
<td>Array</td>
<td>[]</td>
<td>扩展节点可插入的图标，数组的每一项为一个对象，对象详细结构请参考下方【图标配置】表格</td>
</tr>
<tr>
<td>maxNodeCacheCount（v0.5.10+）</td>
<td>Number</td>
<td>1000</td>
<td>节点最大缓存数量。为了优化性能，内部会维护一个节点缓存池，用来复用节点，通过该属性可以指定池的最大缓存数量</td>
</tr>
<tr>
<td>defaultAssociativeLineText（v0.5.11+）</td>
<td>String</td>
<td>关联</td>
<td>关联线默认文字</td>
</tr>
<tr>
<td>fitPadding（v0.6.0+）</td>
<td>Number</td>
<td>50</td>
<td>思维导图适应画布大小时的内边距，单位：px</td>
</tr>
<tr>
<td>enableCtrlKeyNodeSelection（v0.6.0+）</td>
<td>Boolean</td>
<td>true</td>
<td>是否开启按住ctrl键多选节点的功能</td>
</tr>
<tr>
<td>useLeftKeySelectionRightKeyDrag（v0.6.0+）</td>
<td>Boolean</td>
<td>false</td>
<td>设置为左键多选节点，右键拖动画布</td>
</tr>
<tr>
<td>beforeTextEdit（v0.6.0+）</td>
<td>Function/null</td>
<td>null</td>
<td>节点即将进入编辑前的回调方法，如果该方法返回true以外的值，那么将取消编辑，函数可以返回一个值，或一个Promise，回调参数为节点实例</td>
</tr>
<tr>
<td>isUseCustomNodeContent（v0.6.3+）</td>
<td>Boolean</td>
<td>false</td>
<td>是否自定义节点内容</td>
</tr>
<tr>
<td>customCreateNodeContent（v0.6.3+）</td>
<td>Function/null</td>
<td>null</td>
<td>如果<code>isUseCustomNodeContent</code>设为<code>true</code>，那么需要使用该选项传入一个方法，接收节点实例<code>node</code>为参数（如果要获取该节点的数据，可以通过<code>node.nodeData.data</code>），需要返回自定义节点内容元素，也就是DOM节点，如果某个节点不需要自定义，那么返回<code>null</code>即可</td>
</tr>
<tr>
<td>mouseScaleCenterUseMousePosition（v0.6.4-fix.1+）</td>
<td>Boolean</td>
<td>true</td>
<td>鼠标缩放是否以鼠标当前位置为中心点，否则以画布中心点</td>
</tr>
<tr>
<td>customInnerElsAppendTo（v0.6.12+）</td>
<td>null/HTMLElement</td>
<td>null</td>
<td>指定内部一些元素（节点文本编辑元素、节点备注显示元素、关联线文本编辑元素、节点图片调整按钮元素）添加到的位置，默认添加到document.body下</td>
</tr>
<tr>
<td>nodeDragPlaceholderMaxSize（v0.6.12+）</td>
<td>Number</td>
<td>20</td>
<td>拖拽元素时，指示元素新位置的块的最大高度</td>
</tr>
<tr>
<td>enableCreateHiddenInput（v0.6.13+）（v0.6.14+版本已去除该特性）</td>
<td>Boolean</td>
<td>true</td>
<td>是否允许创建一个隐藏的输入框，该输入框会在节点激活时聚焦，用于粘贴数据和自动进入文本编辑状态</td>
</tr>
<tr>
<td>enableAutoEnterTextEditWhenKeydown（v0.6.13+）</td>
<td>Boolean</td>
<td>true</td>
<td>是否在存在一个激活节点时，当按下中文、英文、数字按键时自动进入文本编辑模式</td>
</tr>
<tr>
<td>richTextEditFakeInPlace（v0.6.13+）</td>
<td>Boolean</td>
<td>false</td>
<td>设置富文本节点编辑框和节点大小一致，形成伪原地编辑的效果，需要注意的是，只有当节点内只有文本、且形状是矩形才会有比较好的效果</td>
</tr>
<tr>
<td>customHandleClipboardText（v0.6.14+）</td>
<td>Function</td>
<td>null</td>
<td>自定义对剪贴板文本的处理。当按ctrl+v粘贴时会读取用户剪贴板中的文本和图片，默认只会判断文本是否是普通文本和simple-mind-map格式的节点数据，如果你想处理其他思维导图的数据，比如processon、zhixi等，那么可以传递一个函数，接受当前剪贴板中的文本为参数，返回处理后的数据，可以返回两种类型：1.返回一个纯文本，那么会直接以该文本创建一个子节点；2.返回一个节点对象，格式如下：{ simpleMindMap: true, data: { data: { text: '' }, children: [] } }，代表是simple-mind-map格式的数据，节点数据同simple-mind-map节点数据格式，如果你的处理逻辑存在异步逻辑，也可以返回一个promise</td>
</tr>
<tr>
<td>errorHandler（v0.6.15+）</td>
<td>Function</td>
<td></td>
<td>自定义错误处理函数，目前只会抛出一些异步逻辑出错的情况。可以传递一个函数，会接收两个参数，第一个为错误的类型，第二个为错误对象</td>
</tr>
<tr>
<td>disableMouseWheelZoom（v0.6.15+）</td>
<td>Boolean</td>
<td>false</td>
<td>禁止鼠标滚轮缩放，你仍旧可以使用api进行缩放</td>
</tr>
<tr>
<td>resetCss（v0.6.16+）</td>
<td>String</td>
<td>* { margin: 0; padding: 0; box-sizing: border-box; }</td>
<td>设置导出图片和svg时，针对富文本节点内容，也就是嵌入到svg中的html节点的默认样式覆盖，如果不覆盖，节点内容会发生偏移</td>
</tr>
<tr>
<td>enableDblclickReset（v0.6.17+）（v0.8.0+已删除该属性）</td>
<td>Boolean</td>
<td>true（v0.7.0+改为false）</td>
<td>开启鼠标双击复位思维导图位置及缩放</td>
</tr>
<tr>
<td>enableDblclickBackToRootNode（v0.8.0+）</td>
<td>Boolean</td>
<td>false</td>
<td>是否在鼠标双击时回到根节点，也就是让根节点居中显示</td>
</tr>
<tr>
<td>minExportImgCanvasScale（v0.7.0+）</td>
<td>Number</td>
<td>2</td>
<td>导出图片和pdf时canvas的缩放倍数，该配置会和window.devicePixelRatio值取最大值，用于提升图片清晰度</td>
</tr>
<tr>
<td>hoverRectColor（v0.7.0+）</td>
<td>String</td>
<td>rgb(94, 200, 248)</td>
<td>节点鼠标hover和激活时显示的矩形边框颜色，hover时会添加0.6的透明度</td>
</tr>
<tr>
<td>hoverRectPadding（v0.7.0+）</td>
<td>Number</td>
<td>2</td>
<td>节点鼠标hover和激活时显示的矩形边框距节点内容的距离</td>
</tr>
<tr>
<td>selectTextOnEnterEditText（v0.7.0+）</td>
<td>Boolean</td>
<td>true</td>
<td>双击节点进入节点文本编辑时是否默认选中文本，默认只在创建新节点时会选中</td>
</tr>
<tr>
<td>deleteNodeActive（v0.7.1+）</td>
<td>Boolean</td>
<td>true</td>
<td>是否开启删除节点后自动激活节点相邻节点或父节点的功能</td>
</tr>
<tr>
<td>autoMoveWhenMouseInEdgeOnDrag（v0.7.1+）</td>
<td>Boolean</td>
<td>true</td>
<td>拖拽节点时鼠标移动到画布边缘是否开启画布自动移动</td>
</tr>
<tr>
<td>fit（v0.7.1-fix.2+）</td>
<td>Boolean</td>
<td>false</td>
<td>首次渲染时是否缩放至适应画布大小</td>
</tr>
<tr>
<td>dragMultiNodeRectConfig（v0.7.2+）</td>
<td>Object</td>
<td>{ width: 40, height: 20, fill: '' }</td>
<td>拖拽多个节点时随鼠标移动的示意矩形的样式配置，传递一个对象，字段含义分别为矩形的宽、高、填充色</td>
</tr>
<tr>
<td>dragPlaceholderRectFill（v0.7.2+）</td>
<td>String</td>
<td></td>
<td>节点拖拽时新位置的示意矩形的填充颜色，如果不传默认使用连线的颜色</td>
</tr>
<tr>
<td>dragOpacityConfig（v0.7.2+）</td>
<td>Object</td>
<td>{ cloneNodeOpacity: 0.5, beingDragNodeOpacity: 0.3 }</td>
<td>节点拖拽时的透明度配置，传递一个对象，字段含义分别为：跟随鼠标移动的克隆节点或矩形的透明度、被拖拽节点的透明度</td>
</tr>
<tr>
<td>tagsColorMap（v0.7.2+）</td>
<td>Object</td>
<td>{}</td>
<td>自定义节点标签的颜色，可传一个对象，key为要指定颜色的标签内容，value为该标签内容的颜色，如果不传内部会根据标签内容生成对应的颜色</td>
</tr>
<tr>
<td>cooperateStyle（v0.7.3+）</td>
<td>Object</td>
<td>{ avatarSize: 22, fontSize: 12 }</td>
<td>节点协作编辑时的人员头像样式配置，字段含义分别为：头像大小、如果是文字头像，那么文字的大小</td>
</tr>
<tr>
<td>associativeLineIsAlwaysAboveNode（v0.8.0+）</td>
<td>Boolean</td>
<td>true</td>
<td>关联线是否始终显示在节点上层，如果设为false，那么创建关联线和激活关联线时处于最顶层，其他情况下处于节点下方</td>
</tr>
<tr>
<td>defaultGeneralizationText（v0.8.0+）</td>
<td>String</td>
<td>概要</td>
<td>插入概要的默认文本</td>
</tr>
<tr>
<td>handleIsSplitByWrapOnPasteCreateNewNode（v0.8.0+）</td>
<td>Function / null</td>
<td>null</td>
<td>粘贴文本的方式创建新节点时，控制是否按换行自动分割节点，即如果存在换行，那么会根据换行创建多个节点，否则只会创建一个节点，可以传递一个函数，返回promise，resolve代表根据换行分割，reject代表忽略换行</td>
</tr>
<tr>
<td>addHistoryTime（v0.8.0+）</td>
<td>Number</td>
<td>100</td>
<td>指定时间内只允许添加一次历史记录，避免添加没有必要的中间状态，单位：ms</td>
</tr>
<tr>
<td>isDisableDrag（v0.8.1+）</td>
<td>Boolean</td>
<td>false</td>
<td>是否禁止拖动画布</td>
</tr>
<tr>
<td>disableTouchZoom（v0.8.1+）</td>
<td>Boolean</td>
<td>false</td>
<td>禁止双指缩放，你仍旧可以使用api进行缩放，对TouchEvent插件生效</td>
</tr>
<tr>
<td>highlightNodeBoxStyle（v0.9.0+）</td>
<td>Object</td>
<td>{ stroke: 'rgb(94, 200, 248)', fill: 'transparent' }</td>
<td>鼠标移入概要高亮所属节点时的高亮框样式</td>
</tr>
<tr>
<td>createNewNodeBehavior（v0.9.1+）</td>
<td>String</td>
<td>default</td>
<td>创建新节点时的行为。default（默认会激活新创建的节点，并且进入编辑模式。如果同时创建了多个新节点，那么只会激活而不会进入编辑模式）、notActive（不激活新创建的节点）、activeOnly（只激活新创建的节点，不进入编辑模式）</td>
</tr>
</tbody>
</table>
<h3>数据结构</h3>
<p>基本的数据结构如下：</p>
<pre class="hljs"><code>{
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 节点的文本，可以是富文本，也就是html格式的，此时richText要设为true</span>
    <span class="hljs-attr">richText</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 节点的文本是否是富文本模式</span>
    <span class="hljs-attr">expand</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 节点是否展开</span>
    <span class="hljs-attr">uid</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">// 节点唯一的id，可不传，内部会生成</span>
    <span class="hljs-attr">icon</span>: [], <span class="hljs-comment">// 图标，格式可参考教程里的【插入和扩展节点图标】章节</span>
    <span class="hljs-attr">image</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 图片的url</span>
    <span class="hljs-attr">imageTitle</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 图片的标题，可为空</span>
    <span class="hljs-attr">imageSize</span>: { <span class="hljs-comment">// 图片的尺寸</span>
      <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>, <span class="hljs-comment">// 图片的宽度，必传</span>
      <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>, <span class="hljs-comment">// 图片的高度，必传</span>
      <span class="hljs-attr">custom</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 如果设为true，图片的显示大小不受主题控制，以imageSize.width和imageSize.height为准</span>
    },
    <span class="hljs-attr">hyperlink</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 超链接地址</span>
    <span class="hljs-attr">hyperlinkTitle</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 超链接的标题</span>
    <span class="hljs-attr">note</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 备注的内容</span>
    <span class="hljs-attr">tag</span>: [], <span class="hljs-comment">// 标签列表</span>
    <span class="hljs-attr">generalization</span>: {<span class="hljs-comment">// 节点的概要，如果没有概要generalization设为null即可</span>
      <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">// 概要的文本</span>
    },
    <span class="hljs-attr">associativeLineTargets</span>: [<span class="hljs-string">&#x27;&#x27;</span>],<span class="hljs-comment">// 如果存在关联线，那么为目标节点的uid列表</span>
    <span class="hljs-attr">associativeLineText</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">// 关联线文本</span>
    <span class="hljs-comment">// ...其他样式字段，可以参考主题</span>
  },
  children [<span class="hljs-comment">// 子节点，结构和根节点一致</span>
    {
      <span class="hljs-attr">data</span>: {},
      <span class="hljs-attr">children</span>: []
    }
  ]
}
</code></pre>
<p>如果你要添加自定义的字段，可以添加到<code>data</code>、<code>children</code>同级，如果你要添加到<code>data</code>对象里，那么请使用<code>_</code>开头来命名你的自定义字段，内部会通过这个来判断是否是自定义字段。</p>
<h3>水印配置</h3>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td>String</td>
<td>''</td>
<td>水印文字，如果为空字符串则不显示水印</td>
</tr>
<tr>
<td>lineSpacing</td>
<td>Number</td>
<td>100</td>
<td>水印每行之间的间距</td>
</tr>
<tr>
<td>textSpacing</td>
<td>Number</td>
<td>100</td>
<td>同一行水印之间的间距</td>
</tr>
<tr>
<td>angle</td>
<td>Number</td>
<td>30</td>
<td>水印的倾斜角度，范围：[0, 90]</td>
</tr>
<tr>
<td>textStyle</td>
<td>Object</td>
<td>{color: '#999', opacity: 0.5, fontSize: 14}</td>
<td>水印文字样式</td>
</tr>
</tbody>
</table>
<h3>图标配置</h3>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>String</td>
<td></td>
<td>图标分组的名称</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td></td>
<td>图标分组的值</td>
</tr>
<tr>
<td>list</td>
<td>Array</td>
<td></td>
<td>分组下的图标列表，数组的每一项为一个对象，<code>{ name: '', icon: '' }</code>，<code>name</code>代表图标的名称，<code>icon</code>代表图标，可以是<code>svg</code>图标，比如<code>&lt;svg ...&gt;&lt;path&gt;&lt;/path&gt;&lt;/svg&gt;</code>，也可以是图片<code>url</code>，或者是<code>base64</code>图标，比如<code>data:image/png;base64,...</code></td>
</tr>
</tbody>
</table>
<h2>静态方法</h2>
<h3>defineTheme(name, config)</h3>
<blockquote>
<p>v0.2.23+</p>
</blockquote>
<p>定义新主题。</p>
<p><code>name</code>：新主题名称</p>
<p><code>config</code>：主题数据</p>
<p><code>simple-mind-map</code>内置了众多主题，另外你也可以注册新主题，建议在实例化之前进行注册，这样在实例化时可以直接使用新注册的主题，使用示例：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> MindMap <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;simple-mind-map&#x27;</span>
<span class="hljs-comment">// 注册新主题</span>
MindMap.defineTheme(<span class="hljs-string">&#x27;主题名称&#x27;</span>, {})

<span class="hljs-comment">// 1.实例化时使用新注册的主题</span>
<span class="hljs-keyword">const</span> mindMap = <span class="hljs-keyword">new</span> MindMap({
    <span class="hljs-attr">theme</span>: <span class="hljs-string">&#x27;主题名称&#x27;</span>
})

<span class="hljs-comment">// 2.动态切换新主题</span>
mindMap.setTheme(<span class="hljs-string">&#x27;主题名称&#x27;</span>)
</code></pre>
<p>主题的所有配置可以参考<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/src/themes/default.js">默认主题</a>。<code>defineTheme</code>方法会把你传入的配置和默认配置做合并。大部分主题其实需要自定义的部分不是很多，一个典型的自定义主题配置可以参考<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/src/themes/blueSky.js">blueSky</a>。</p>
<h3>usePlugin(plugin, opt = {})</h3>
<blockquote>
<p>v0.3.0+</p>
</blockquote>
<ul>
<li><code>opt</code>：v0.4.0+，插件参数。如果某个插件支持自定义选项的话可以通过这个参数传入。</li>
</ul>
<p>注册插件，如果需要使用非核心的一些功能，比如小地图、水印等，可以通过该方法进行注册。可链式调用。</p>
<p>注意：插件需要在实例化<code>MindMap</code>前注册。</p>
<h3>hasPlugin(plugin)</h3>
<blockquote>
<p>v0.4.0+</p>
</blockquote>
<p>获取是否注册了某个插件，返回的是插件在注册插件列表里的索引，为<code>-1</code>则代表插件没有注册。</p>
<h2>静态属性</h2>
<h3>pluginList</h3>
<blockquote>
<p>v0.3.0+</p>
</blockquote>
<p>当前注册的所有插件列表。</p>
<h2>实例属性</h2>
<h3>el</h3>
<p>容器元素。</p>
<h3>opt</h3>
<p>配置选项对象。</p>
<h3>svg</h3>
<blockquote>
<p>@svgdotjs/svg.js库调用SVG()方法返回的节点实例</p>
</blockquote>
<p>画布svg元素。</p>
<h3>draw</h3>
<blockquote>
<p>@svgdotjs/svg.js库调用group()方法返回的节点实例</p>
<p>svg节点的子节点</p>
</blockquote>
<p>容器元素，用于承载节点、连线等内容。</p>
<h3>lineDraw</h3>
<blockquote>
<p>v0.8.0+</p>
<p>@svgdotjs/svg.js库调用group()方法返回的节点实例</p>
<p>draw节点的子节点</p>
</blockquote>
<p>节点连线元素的容器。</p>
<h3>nodeDraw</h3>
<blockquote>
<p>v0.8.0+</p>
<p>@svgdotjs/svg.js库调用group()方法返回的节点实例</p>
<p>draw节点的子节点</p>
</blockquote>
<p>节点元素的容器。</p>
<h3>associativeLineDraw</h3>
<blockquote>
<p>v0.8.0+</p>
<p>@svgdotjs/svg.js库调用group()方法返回的节点实例</p>
<p>在注册了关联线插件的情况下可用</p>
<p>draw节点的子节点</p>
</blockquote>
<p>关联线内容的容器。</p>
<h3>otherDraw</h3>
<blockquote>
<p>v0.8.0+</p>
<p>@svgdotjs/svg.js库调用group()方法返回的节点实例</p>
<p>draw节点的子节点</p>
</blockquote>
<p>其他内容的容器。</p>
<h3>elRect</h3>
<p>容器元素<code>el</code>的尺寸、位置信息。调用<code>getBoundingClientRect()</code>方法的返回结果。</p>
<h3>width</h3>
<p>容器元素<code>el</code>的宽度。</p>
<h3>height</h3>
<p>容器元素<code>el</code>的高度。</p>
<h3>themeConfig</h3>
<p>当前主题配置。</p>
<h2>实例方法</h2>
<h3>clearDraw()</h3>
<blockquote>
<p>v0.8.0+</p>
</blockquote>
<p>清空<code>lineDraw</code>、<code>associativeLineDraw</code>、<code>nodeDraw</code>、<code>otherDraw</code>容器。</p>
<h3>destroy()</h3>
<blockquote>
<p>v0.6.0+</p>
</blockquote>
<p>销毁思维导图。会移除注册的插件、移除监听的事件、删除画布的所有节点。</p>
<h3>getSvgData({ paddingX = 0, paddingY = 0, ignoreWatermark = false })</h3>
<blockquote>
<p>v0.3.0+</p>
</blockquote>
<p><code>paddingX</code>：水平内边距</p>
<p><code>paddingY</code>：垂直内边距</p>
<p><code>ignoreWatermark</code>：v0.8.0+，不要绘制水印，如果不需要绘制水印的场景可以传<code>true</code>，因为绘制水印非常慢</p>
<p>获取<code>svg</code>数据，返回一个对象，详细结构如下：</p>
<pre class="hljs"><code>{
  svg, <span class="hljs-comment">// Element，思维导图图形的整体svg元素，包括：svg（画布容器）、g（实际的思维导图组）</span>
  svgHTML, <span class="hljs-comment">// String，svg字符串，即html字符串，可以直接渲染到你准备的小地图容器内</span>
  <span class="hljs-attr">rect</span>: <span class="hljs-comment">// Object，思维导图图形未缩放时的位置尺寸等信息</span>
  origWidth, <span class="hljs-comment">// Number，画布宽度</span>
  origHeight, <span class="hljs-comment">// Number，画布高度</span>
  scaleX, <span class="hljs-comment">// Number，思维导图图形的水平缩放值</span>
  scaleY, <span class="hljs-comment">// Number，思维导图图形的垂直缩放值</span>
}
</code></pre>
<h3>render(callback)</h3>
<ul>
<li><code>callback</code>：<code>v0.3.2+</code>，<code>Function</code>，当重新渲染完成时调用</li>
</ul>
<p>触发整体渲染，会进行节点复用，性能较<code>reRender</code>会更好一点，如果只是节点位置变化了可以调用该方法进行渲染</p>
<h3>reRender(callback)</h3>
<ul>
<li><code>callback</code>：<code>v0.3.2+</code>，<code>Function</code>，当重新渲染完成时调用</li>
</ul>
<p>整体重新渲染，会清空画布，节点也会重新创建，性能不好，慎重使用</p>
<h3>resize()</h3>
<p>容器尺寸变化后，需要调用该方法进行适应</p>
<h3>setMode(mode)</h3>
<blockquote>
<p>v0.1.7+</p>
</blockquote>
<p>切换模式为只读或编辑。</p>
<p><code>mode</code>：readonly、edit</p>
<h3>on(event, fn)</h3>
<p>监听事件，事件列表：</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>描述</th>
<th>回调参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>data_change</td>
<td>渲染树数据变化，可以监听该方法获取最新数据</td>
<td>data（当前渲染树数据）</td>
</tr>
<tr>
<td>view_data_change（v0.1.1+）</td>
<td>视图变化数据，比如拖动或缩放时会触发</td>
<td>data（当前视图状态数据）</td>
</tr>
<tr>
<td>back_forward</td>
<td>前进或回退</td>
<td>activeHistoryIndex（当前在历史数据数组里的索引）、length（当前历史数据数组的长度）</td>
</tr>
<tr>
<td>draw_click</td>
<td><em>画布的单击事件</em></td>
<td>e（事件对象）</td>
</tr>
<tr>
<td>svg_mousedown</td>
<td>svg画布的鼠标按下事件</td>
<td>e（事件对象）</td>
</tr>
<tr>
<td>mousedown</td>
<td>el元素的鼠标按下事件</td>
<td>e（事件对象）、this（Event事件类实例）</td>
</tr>
<tr>
<td>mousemove</td>
<td>el元素的鼠标移动事件</td>
<td>e（事件对象）、this（Event事件类实例）</td>
</tr>
<tr>
<td>drag</td>
<td>如果是按住左键拖动的话会触发拖动事件</td>
<td>e（事件对象）、this（Event事件类实例）</td>
</tr>
<tr>
<td>mouseup</td>
<td>el元素的鼠标松开事件</td>
<td>e（事件对象）、this（Event事件类实例）</td>
</tr>
<tr>
<td>mousewheel</td>
<td>鼠标滚动事件</td>
<td>e（事件对象）、dir（向上up还是向下down滚动）、this（Event事件类实例）、isTouchPad（v0.6.1+，是否是触控板触发的事件）</td>
</tr>
<tr>
<td>contextmenu</td>
<td>svg画布的鼠标右键菜单事件</td>
<td>e（事件对象）</td>
</tr>
<tr>
<td>node_click</td>
<td>节点的单击事件</td>
<td>this（节点实例）、e（事件对象）</td>
</tr>
<tr>
<td>node_mousedown</td>
<td>节点的鼠标按下事件</td>
<td>this（节点实例）、e（事件对象）</td>
</tr>
<tr>
<td>node_mouseup</td>
<td>节点的鼠标松开事件</td>
<td>this（节点实例）、e（事件对象）</td>
</tr>
<tr>
<td>node_dblclick</td>
<td>节点的双击事件</td>
<td>this（节点实例）、e（事件对象）</td>
</tr>
<tr>
<td>node_contextmenu</td>
<td>节点的右键菜单事件</td>
<td>e（事件对象）、this（节点实例）</td>
</tr>
<tr>
<td>node_mouseenter（v0.4.1+）</td>
<td>节点的鼠标移入事件</td>
<td>this（节点实例）、e（事件对象）</td>
</tr>
<tr>
<td>node_mouseleave（v0.4.1+）</td>
<td>节点的鼠标移出事件</td>
<td>this（节点实例）、e（事件对象）</td>
</tr>
<tr>
<td>before_node_active</td>
<td>节点激活前事件</td>
<td>this（节点实例）、activeNodeList（当前激活的所有节点列表）</td>
</tr>
<tr>
<td>node_active</td>
<td>节点激活事件</td>
<td>this（节点实例）、activeNodeList（当前激活的所有节点列表）</td>
</tr>
<tr>
<td>expand_btn_click</td>
<td>节点展开或收缩事件</td>
<td>this（节点实例）</td>
</tr>
<tr>
<td>before_show_text_edit</td>
<td>节点文本编辑框即将打开事件</td>
<td></td>
</tr>
<tr>
<td>hide_text_edit</td>
<td>节点文本编辑框关闭事件</td>
<td>textEditNode（文本编辑框DOM节点）、activeNodeList（当前激活的所有节点列表）</td>
</tr>
<tr>
<td>scale</td>
<td>放大缩小事件</td>
<td>scale（缩放比例）</td>
</tr>
<tr>
<td>node_img_dblclick（v0.2.15+）</td>
<td>节点内图片的双击事件</td>
<td>this（节点实例）、e（事件对象）</td>
</tr>
<tr>
<td>node_img_mouseenter（v0.6.5+）</td>
<td>节点内图片的鼠标移入事件</td>
<td>this（节点实例）、imgNode（图片节点）、e（事件对象）</td>
</tr>
<tr>
<td>node_img_mouseleave（v0.6.5+）</td>
<td>节点内图片的鼠标移出事件</td>
<td>this（节点实例）、imgNode（图片节点）、e（事件对象）</td>
</tr>
<tr>
<td>node_img_mousemove（v0.6.5+）</td>
<td>节点内图片的鼠标移动事件</td>
<td>this（节点实例）、imgNode（图片节点）、e（事件对象）</td>
</tr>
<tr>
<td>node_tree_render_end（v0.2.16+）</td>
<td>节点树渲染完毕事件</td>
<td></td>
</tr>
<tr>
<td>rich_text_selection_change（v0.4.0+）</td>
<td>当注册了<code>RichText</code>插件时可用。当节点编辑时，文本选区发生改变时触发</td>
<td>hasRange（是否存在选区）、rectInfo（选区的尺寸和位置信息）、formatInfo（选区的文本格式化信息）</td>
</tr>
<tr>
<td>transforming-dom-to-images（v0.4.0+）</td>
<td>当注册了<code>RichText</code>插件时可用。当<code>svg</code>中存在<code>DOM</code>节点时，导出为图片时会将<code>DOM</code>节点转换为图片，转换过程中会触发该事件，可用通过该事件给用户提示，告知目前转换到的节点</td>
<td>index（当前转换到的节点索引）、len（一共需要转换的节点数量）</td>
</tr>
<tr>
<td>node_dragging（v0.4.5+）</td>
<td>当某个节点被拖拽时触发</td>
<td>node（当前被拖拽的节点）</td>
</tr>
<tr>
<td>node_dragend（v0.4.5+）</td>
<td>节点被拖拽结束时触发</td>
<td>{ overlapNodeUid, prevNodeUid, nextNodeUid }（v0.6.12+，本次节点移动到的节点uid，比如本次移动到了节点A上，那么overlapNodeUid就是节点A的uid，如果移动到了B节点的前面，那么nextNodeUid就是节点B的uid，你可以通过mindMap.renderer.findNodeByUid(uid)方法来获取节点实例）</td>
</tr>
<tr>
<td>associative_line_click（v0.4.5+）</td>
<td>点击某条关联线时触发</td>
<td>path（连接线节点）、clickPath（不可见的点击线节点）、node（起始节点）、toNode（目标节点）</td>
</tr>
<tr>
<td>svg_mouseenter（v0.5.1+）</td>
<td>鼠标移入svg画布时触发</td>
<td>e（事件对象）</td>
</tr>
<tr>
<td>svg_mouseleave（v0.5.1+）</td>
<td>鼠标移出svg画布时触发</td>
<td>e（事件对象）</td>
</tr>
<tr>
<td>node_icon_click（v0.6.10+）</td>
<td>点击节点内的图标时触发</td>
<td>this（节点实例）、item（点击的图标名称）、e（事件对象）</td>
</tr>
<tr>
<td>view_theme_change（v0.6.12+）</td>
<td>调用了setTheme方法设置主题后触发</td>
<td>theme（设置的新主题名称）</td>
</tr>
<tr>
<td>set_data（v0.7.3+）</td>
<td>调用了setData方法动态设置思维导图数据时触发</td>
<td>data（新的思维导图数据）</td>
</tr>
<tr>
<td>resize（v0.8.0+）</td>
<td>容器尺寸改变后触发，实际上是当思维导图实例的<code>resize</code>方法被调用后触发</td>
<td></td>
</tr>
<tr>
<td>beforeDestroy（v0.9.0+）</td>
<td>思维导图销毁前触发，即调用了destroy方法触发</td>
<td></td>
</tr>
</tbody>
</table>
<h3>emit(event, ...args)</h3>
<p>触发事件，可以是上面表格里的事件，也可以是自定义事件</p>
<h3>off(event, fn)</h3>
<p>解绑事件</p>
<h3>setTheme(theme, notRender = false)</h3>
<ul>
<li><code>notRender</code>：v0.8.0+，是否不要调用render方法更新画布。</li>
</ul>
<p>切换主题，可选主题见上面的选项表格</p>
<h3>getTheme()</h3>
<p>获取当前主题</p>
<h3>setThemeConfig(config, notRender = false)</h3>
<ul>
<li><code>notRender</code>：v0.8.0+，是否不要调用render方法更新画布。</li>
</ul>
<p>设置主题配置，<code>config</code>同上面选项表格里的选项<code>themeConfig</code></p>
<h3>getCustomThemeConfig()</h3>
<p>获取自定义主题配置</p>
<h3>getThemeConfig(prop)</h3>
<p>获取某个主题配置属性值</p>
<h3>getConfig(<em>prop</em>)</h3>
<blockquote>
<p>0.2.24+</p>
</blockquote>
<p><code>prop</code>：获取指定配置的值，不传则返回整个配置</p>
<p>获取配置，即<code>new MindMap(opt)</code>的<code>opt</code></p>
<h3>updateConfig(<em>opt</em> = {})</h3>
<blockquote>
<p>0.2.24+</p>
</blockquote>
<p><code>opt</code>：要更新的配置</p>
<p>更新配置，即更新<code>new MindMap(opt)</code>的<code>opt</code>，可以只更新部分数据，比如：</p>
<pre class="hljs"><code>mindMap.updateConfig({
    <span class="hljs-attr">enableFreeDrag</span>: <span class="hljs-literal">true</span><span class="hljs-comment">// 开启节点自由拖拽</span>
})
</code></pre>
<p>该方法只做更新配置的事情，没有其他副作用，比如触发画布重新渲染之类的</p>
<h3>getLayout()</h3>
<p>获取当前的布局结构</p>
<h3>setLayout(layout, notRender = false)</h3>
<ul>
<li><code>notRender</code>：v0.8.0+，是否不要调用render方法更新画布。</li>
</ul>
<p>设置布局结构，可选值见上面选项表格的<code>layout</code>字段</p>
<h3>execCommand(name, ...args)</h3>
<p>执行命令，每执行一个命令就会在历史堆栈里添加一条记录用于回退或前进。所有命令如下：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>描述</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT_ALL</td>
<td>全选</td>
<td></td>
</tr>
<tr>
<td>BACK</td>
<td>回退指定的步数</td>
<td>step（要回退的步数，默认为1）</td>
</tr>
<tr>
<td>FORWARD</td>
<td>前进指定的步数</td>
<td>step（要前进的步数，默认为1）</td>
</tr>
<tr>
<td>INSERT_NODE</td>
<td>插入同级节点，操作节点为当前激活的节点或指定节点，如果有多个激活节点，只会对第一个有效（v0.7.2+支持对多个激活节点同时插入兄弟节点）</td>
<td>openEdit（v0.4.6+，是否激活新插入的节点并进入编辑模式，默认为<code>true</code>）、 appointNodes（v0.4.7+，可选，指定要插入兄弟节点的节点，指定多个节点可以传一个数组）、 appointData（可选，指定新创建节点的数据，比如{text: 'xxx', ...}，详细结构可以参考<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/example/exampleData.js">exampleData.js</a>）、 appointChildren（v0.6.14+，可选，指定新创建节点的子节点，数组类型）</td>
</tr>
<tr>
<td>INSERT_CHILD_NODE</td>
<td>插入子节点，操作节点为当前激活的节点或指定节点</td>
<td>openEdit（v0.4.6+，是否激活新插入的节点并进入编辑模式，默认为<code>true</code>）、 appointNodes（v0.4.7+，可选，指定节点，指定多个节点可以传一个数组）、 appointData（可选，指定新创建节点的数据，比如{text: 'xxx', ...}，详细结构可以参考<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/example/exampleData.js">exampleData.js</a>）、 appointChildren（v0.6.14+，可选，指定新创建节点的子节点，数组类型）</td>
</tr>
<tr>
<td>UP_NODE</td>
<td>上移节点，操作节点为当前激活的节点，如果有多个激活节点，只会对第一个有效，对根节点或在列表里的第一个节点使用无效</td>
<td></td>
</tr>
<tr>
<td>DOWN_NODE</td>
<td>操作节点为当前激活的节点，如果有多个激活节点，只会对第一个有效，对根节点或在列表里的最后一个节点使用无效</td>
<td></td>
</tr>
<tr>
<td>REMOVE_NODE</td>
<td>删除节点，操作节点为当前激活的节点或指定节点</td>
<td>appointNodes（v0.4.7+，可选，指定节点，指定多个节点可以传一个数组）</td>
</tr>
<tr>
<td>PASTE_NODE</td>
<td>粘贴节点到节点，操作节点为当前激活的节点</td>
<td>data（要粘贴的节点数据，一般通过<code>renderer.copyNode()</code>方法和<code>renderer.cutNode()</code>方法获取）</td>
</tr>
<tr>
<td>CUT_NODE</td>
<td>剪切节点，操作节点为当前激活的节点，如果有多个激活节点，只会对第一个有效，对根节点使用无效</td>
<td>callback(回调函数，剪切的节点数据会通过调用该函数并通过参数返回)</td>
</tr>
<tr>
<td>SET_NODE_STYLE</td>
<td>修改节点单个样式</td>
<td>node（要设置样式的节点）、style（样式属性）、value（样式属性值）、isActive（v0.7.0+已废弃，布尔值，是否设置的是激活状态的样式）</td>
</tr>
<tr>
<td>SET_NODE_STYLEs（v0.6.12+）</td>
<td>修改节点多个样式</td>
<td>node（要设置样式的节点）、style（样式对象，key为样式属性，value为样式值）、isActive（v0.7.0+已废弃，布尔值，是否设置的是激活状态的样式）</td>
</tr>
<tr>
<td>SET_NODE_ACTIVE</td>
<td>设置节点是否激活</td>
<td>node（要设置的节点）、active（布尔值，是否激活）</td>
</tr>
<tr>
<td>CLEAR_ACTIVE_NODE</td>
<td>清除当前已激活节点的激活状态，操作节点为当前激活的节点</td>
<td></td>
</tr>
<tr>
<td>SET_NODE_EXPAND</td>
<td>设置节点是否展开</td>
<td>node（要设置的节点）、expand（布尔值，是否展开）</td>
</tr>
<tr>
<td>EXPAND_ALL</td>
<td>展开所有节点</td>
<td></td>
</tr>
<tr>
<td>UNEXPAND_ALL</td>
<td>收起所有节点</td>
<td></td>
</tr>
<tr>
<td>UNEXPAND_TO_LEVEL（v0.2.8+）</td>
<td>展开到指定层级</td>
<td>level（要展开到的层级，1、2、3...）</td>
</tr>
<tr>
<td>SET_NODE_DATA</td>
<td>更新节点数据，即更新节点数据对象里<code>data</code>对象的数据</td>
<td>node（要设置的节点）、data（对象，要更新的数据，如<code>{expand: true}</code>）</td>
</tr>
<tr>
<td>SET_NODE_TEXT</td>
<td>设置节点文本</td>
<td>node（要设置的节点）、text（要设置的文本字符串，换行可以使用<code>\n</code>）、richText（v0.4.0+，如果要设置的是富文本字符，需要设为<code>true</code>）、resetRichText（v0.6.10+是否要复位富文本，默认为false，如果传true那么会重置富文本节点的样式）</td>
</tr>
<tr>
<td>SET_NODE_IMAGE</td>
<td>设置节点图片</td>
<td>node（要设置的节点）、imgData（对象，图片信息，结构为：<code>{url, title, width, height}</code>，图片的宽高必须要传）</td>
</tr>
<tr>
<td>SET_NODE_ICON</td>
<td>设置节点图标</td>
<td>node（要设置的节点）、icons（数组，预定义的图片名称组成的数组，可用图标可在<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/src/svg/icons.js">icons.js</a>文件里的<code>nodeIconList</code>列表里获取到，图标名称为<code>type_name</code>，如<code>['priority_1']</code>）</td>
</tr>
<tr>
<td>SET_NODE_HYPERLINK</td>
<td>设置节点超链接</td>
<td>node（要设置的节点）、link（超链接地址）、title（超链接名称，可选）</td>
</tr>
<tr>
<td>SET_NODE_NOTE</td>
<td>设置节点备注</td>
<td>node（要设置的节点）、note（备注文字）</td>
</tr>
<tr>
<td>SET_NODE_TAG</td>
<td>设置节点标签</td>
<td>node（要设置的节点）、tag（字符串数组，内置颜色信息可在<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/src/constants/constant.js">constant.js</a>里获取到）</td>
</tr>
<tr>
<td>INSERT_AFTER（v0.1.5+）</td>
<td>将节点移动到另一个节点的后面</td>
<td>node（要移动的节点，（v0.7.2+支持传递节点数组实现同时移动多个节点））、 exist（目标节点）</td>
</tr>
<tr>
<td>INSERT_BEFORE（v0.1.5+）</td>
<td>将节点移动到另一个节点的前面，（v0.7.2+支持传递节点数组实现同时移动多个节点）</td>
<td>node（要移动的节点）、 exist（目标节点）</td>
</tr>
<tr>
<td>MOVE_NODE_TO（v0.1.5+）</td>
<td>移动节点作为另一个节点的子节点，（v0.7.2+支持传递节点数组实现同时移动多个节点）</td>
<td>node（要移动的节点）、 toNode（目标节点）</td>
</tr>
<tr>
<td>ADD_GENERALIZATION（v0.2.0+）</td>
<td>添加节点概要</td>
<td>data（概要的数据，对象格式，节点的数字段都支持，默认为{text: '概要'}）</td>
</tr>
<tr>
<td>REMOVE_GENERALIZATION（v0.2.0+）</td>
<td>删除节点概要</td>
<td></td>
</tr>
<tr>
<td>SET_NODE_CUSTOM_POSITION（v0.2.0+）</td>
<td>设置节点自定义位置</td>
<td>node（要设置的节点）、 left（自定义的x坐标，默认为undefined）、 top（自定义的y坐标，默认为undefined）</td>
</tr>
<tr>
<td>RESET_LAYOUT（v0.2.0+）</td>
<td>一键整理布局</td>
<td></td>
</tr>
<tr>
<td>SET_NODE_SHAPE（v0.2.4+）</td>
<td>设置节点形状</td>
<td>node（要设置的节点）、shape（形状，全部形状：<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/src/core/render/node/Shape.js">Shape.js</a>）</td>
</tr>
<tr>
<td>GO_TARGET_NODE（v0.6.7+）</td>
<td>定位到某个节点，如果该节点被收起，那么会自动展开到该节点</td>
<td>node（要定位到的节点实例或节点uid）、callback（v0.6.9+，定位完成后的回调函数）</td>
</tr>
<tr>
<td>INSERT_MULTI_NODE（v0.7.2+）</td>
<td>给指定的节点同时插入多个同级节点，操作节点为当前激活的节点或指定节点</td>
<td>appointNodes（可选，指定节点，指定多个节点可以传一个数组）, nodeList（新插入节点的数据列表，数组类型）</td>
</tr>
<tr>
<td>INSERT_MULTI_CHILD_NODE（v0.7.2+）</td>
<td>给指定的节点同时插入多个子节点，操作节点为当前激活的节点或指定节点</td>
<td>appointNodes（可选，指定节点，指定多个节点可以传一个数组）, childList（新插入节点的数据列表，数组类型）</td>
</tr>
<tr>
<td>INSERT_FORMULA（v0.7.2+）</td>
<td>给节点插入数学公式，操作节点为当前激活的节点或指定节点</td>
<td>formula（要插入的数学公式，LaTeX 语法）, appointNodes（可选，指定要插入公式的节点，多个节点可以传数组，否则默认为当前激活的节点）</td>
</tr>
<tr>
<td>INSERT_PARENT_NODE（v0.8.0+）</td>
<td>给指定的节点插入父节点，操作节点为当前激活的节点或指定节点</td>
<td>openEdit（是否激活新插入的节点并进入编辑模式，默认为<code>true</code>）、 appointNodes（可选，指定要插入父节点的节点，指定多个节点可以传一个数组）、 appointData（可选，指定新创建节点的数据，比如{text: 'xxx', ...}，详细结构可以参考<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/example/exampleData.js">exampleData.js</a>）</td>
</tr>
<tr>
<td>REMOVE_CURRENT_NODE（v0.8.0+）</td>
<td>仅删除当前节点，操作节点为当前激活的节点或指定节点</td>
<td>appointNodes（可选，指定要删除的节点，指定多个节点可以传一个数组）</td>
</tr>
</tbody>
</table>
<h3>setData(data)</h3>
<p>动态设置思维导图数据，纯节点数据</p>
<p><code>data</code>：思维导图结构数据</p>
<h3>setFullData(<em>data</em>)</h3>
<blockquote>
<p>v0.2.7+</p>
</blockquote>
<p>动态设置思维导图数据，包括节点数据、布局、主题、视图</p>
<p><code>data</code>：完整数据，结构可参考<a href="https://github.com/wanglin2/mind-map/blob/main/simple-mind-map/example/exportFullData.json">exportFullData</a></p>
<h3>getData(withConfig)</h3>
<blockquote>
<p>v0.2.9+</p>
</blockquote>
<p>获取思维导图数据</p>
<p><code>withConfig</code>：<code>Boolean</code>，默认为<code>false</code>，即获取的数据只包括节点树，如果传<code>true</code>则会包含主题、布局、视图等数据</p>
<h3>export(type, isDownload, fileName)</h3>
<blockquote>
<p>需要先注册<code>Export</code>插件</p>
</blockquote>
<p>导出</p>
<p><code>type</code>：要导出的类型，可选值：png、svg、json、pdf（v0.2.1+）、smm（本质也是json）</p>
<p><code>isDownload</code>：是否需要直接触发下载，布尔值，默认为<code>false</code></p>
<p><code>fileName</code>：（v0.1.6+）导出文件的名称，默认为<code>思维导图</code></p>
<p>如果是导出为<code>png</code>，那么可以传递第四个参数：</p>
<p><code>transparent</code>：v0.5.7+, <code>Boolean</code>，默认为<code>false</code>，指定导出图片的背景是否是透明的</p>
<p>如果是导出为<code>svg</code>，那么可以传递第四个参数：</p>
<p><code>plusCssText</code>：附加的<code>css</code>样式，如果<code>svg</code>中存在<code>dom</code>节点，想要设置一些针对节点的样式可以通过这个参数传入</p>
<p>如果是导出为<code>json</code>或<code>smm</code>，那么可以传递第四个参数：</p>
<p><code>withConfig</code>：<code>Boolean</code>，默认为<code>true</code>，指定导出的数据中是否包含配置数据，否则只导出纯节点树数据</p>
<h3>toPos(x, y)</h3>
<blockquote>
<p>v0.1.5+</p>
</blockquote>
<p>将浏览器可视窗口的坐标转换成相对于画布的坐标</p>
<h3>addPlugin(plugin, opt)</h3>
<blockquote>
<p>v0.4.0+</p>
</blockquote>
<p>注册插件，使用<code>MindMap.usePlugin</code>注册插件只能在实例化之前，实例化后注册的插件是不会生效的，所以如果想在实例化后注册插件可以使用实例的<code>addPlugin</code>方法。</p>
<h3>removePlugin(plugin)</h3>
<blockquote>
<p>v0.4.0+</p>
</blockquote>
<p>移除注册的插件，无论是通过<code>usePlugin</code>还是<code>addPlugin</code>方法注册的插件都可以移除。</p>

  </div>
</template>

<script>
export default {

}
</script>

<style>

</style>